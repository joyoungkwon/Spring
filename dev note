지금 까지의 개발 정리

새로운 할인 정책 개발
새로운 할인 정책 적용과 문제점
관심사 분리
appConfig 리팩터링
새로운 구조와 할인 정책 적용

"새로운 할인 정책 개발"
다형성 덕분에 새로운 정률 활인 정책 코드를 추가로 개발하는 것 자체는 아무 문제가 없음

" 새로운 할인 정책 적용과 문제점"
새로 개발한 정률 할인 정책을 적용하려고 하니 " 클라이언트 코드" 인 주문 서비스 구현체도 함께 변경해야함
주문서비스 클라이언트가 인터페이스인 DiscountPolicy뿐만 아니라 구체클래스인 FixDiscountPolicy 도 함께 의존 -> 이는 DIP위반

"관심의분리"
어플리케이션을 하나의 공연으로 생각
기존에는 클라이언트가 의존하는 서버 구현 객체를 직접실행하고, 실행함
메인 클래스를 구성하고 어떤 객체를 쓸지 정하고 지정하는 담당의 별도에
기획자 같은 클래스가 나올 시점
이는 AppConfig가 실행
AppConfig는 어플리케이션의 전체 동작 방식을 구성 하기 위해 구현객체를 생성하고 "연결"하는 책임
이제부터 클라이언트 객체는 자신의 역할을 실행하는것만 집중 "권한"이 줄어듬 이는 책임이 명확해짐을 의미

"AppConfig 리펙터링"
구성정보에서 역할과 구현을 명확하게 분리
역할이 잘 드러남
중복제거

"새로운 구조와 할인정책 적용"
정액 할인정책 -> 정률 %할인정책으로 변경
AppConfig의 등장으로 어플리케이션이 크게"사용역역"과 객체를 생성하고 구성(Configuration)하는 영역으로 분리
할인 정책을 변경해도 AppConfig가 있는 구성영역에만 변경하면됨 , 사용영역은 변경할 필요가 없음, 물론 클라이언트 코드인 주문서비스 코드도 변경하지 않음 (OrderServiceClass)





좋은 객체 지향 설계의 5가지 원칙의 적용
"SRP 단일 책임 원칙"
"한클래스는 하나의 책임만 가져야 한다"
클라이언트 객체는 직접 객체를 생성하고 연결하고 실행하는 다양한 책임을 가지고 있었음
SRP 단일 책임 원칙을 따르면서 관심사를 분리함
구현 객체를 생성하고 연결하는 책임은 AppConfig가 담당 ()
클라이언트 객체는 실행하는 책임만 담당하도록 리펙토링


"DIP 의존관계 역전 원칙"
"프로그래머는 추상화에 의존해야하며 구체화의 의존하면 안된다"의존성 주입은 이 원칙을 따르는 방법중 하나다.
새로운 할인 정책을 개발하고 적용을 하려고하니 클라이언트 코드도 함께 변경을 해야했다 -> 의존 관계 직접 주입
OrderService 는 DIP 를 지키며 DiscountPolicy 추상화 인터페이스에 의존하는거 같았지만
FixDiscountPolicy 구체화 구현 클래스에도 함께 의존했다
클라이언트 코드가 DiscountPolicy 추상화 인터페이스에만 의존하도록 코드를 변경했다.
하지만 클라이언트 코드는 인터페이스에만 실행할수 없었다
AppConfig가 FixDiscountPolicy 객체 인스턴스를 클라이언트 코드 대신 생성하여 클라이언트 코드에 의존관계를 주입 하게 했다 ((DI)를 외부에서 넣어줌)
이렇게하여 DIP 원칙을 따르며 NullPointException을 해결했다.


"OCP"
"소프트웨어 요소는 확장에는 열려있으나 변경에는 닫혀있어야 한다"

다향성을 사용하고 클라이언트가 DIP를 지킴
애플리케이션을 사용영역과 구성역역으로 나눔
AppConfig 의존관계를 FixDiscountPolicy -> RateDiscountPolicy 로 변경해서 클라이언트 코드에 주입하므로 클라이언트 코드에서는 변경하지 않아도 됨
"소프트웨어 요소를 새롭게 확장해도 사용영역의 코드 변경은 닫혀있다."


"제어의 역전 IoC"
기존 프로그램은 클라이언트 구현 객체가 스스로 필요한 서버 구현객체를 생성하고 연결하고 실행했다 한마디로 구현 객체가 프로그램의 제어흐름을 스스로 조종했다 개발자 입장에서는 자연스러운 흐름이다
반면에AppConfig가 등장한 이후에 구현 객체는 자신의 로직을 실행하는 역할에만 담당한다 프로그램의 제어 흐름은 이제 AppConfig가 가져간다 

예를 들어 OrderServiceImpl은 필요한 인터페이스들을 호출하지만 어떤 구현 객체들이 실행될지 모른다

프로그램에 대한 제어 흐름에 대한 권한은 모두 AppConfig가 가지고 있다 심지어 OrderServiceImpl 도 AppConfig가 생성한다 그리고 AppConfig는 orderServiceImpl 이 아닌 OrderService 인터페이스의 다른 구현 객체를 생성하고 실행할수도 있다 그런 사실도 모른채 OrderServiceImpl은 묵묵히 자신의 로직을 실행한다
이렇듯 프로그램의 제어 흐름을 직접 제어하는것이 아니라 외부에서 관리하는것을 제어의 역전 Ioc라 한다.

"프레임워크vs라이브러리"

프레임워크가 내가 작성한 코드를 제어하고 , 대신 실행하면 그것은 프레임워크가 맞다 (JUnit)
반면에 내가 작성한 코드가 직접 제어의 흐름을 담당한다면 그것은 프레임워크가 아니라 라이브러리다


의존관계 주입 DI(Dependency Injection)
OrderServiceImpl 은 DiscountPolicy 인터페이스에 의존한다 실제 어떤 구현객체가 사용될지 모른다
의존관계는 "정적인 클래스 의존관계와, 실행시점에 결정되는 동적인 객체(인스턴스) 의존관계 등을 분리하여 생각해야 한다"

"정적인 클래스 의존관계"
클래스가 사용하는 import 코드만 보고 의존관계를 쉽게 판단 할수 있다 정적인의존관계는 애플리캐이션을 실행하지않아도 분리 해석할수 있다
애플리케이션 실행시점 에 외부에서 실제 구현 객체를 생성 하고 클라이언트에 전달해서 클라이언트와 서버의 실제 의존관계가 연결되는 것을 의존관계 주입이라고 한다
객체 인스턴스를 생성하고 그 참조값을 전달해서 연결된다
의존관계 주입을 사용하면 클라이언트 코드를 변경하지않고 클라이언트가 호출하는 대상의 타입 인스턴스를 변경 할수 있다.
의존관계 주입을 사용하면 정적인 클래스 의존관계를 변경하지않고 동적인 객체 인스턴스 의존관계를 쉽게 변경할수 있다.


"IoC컨테이너 DI 컨테이너"
AppConfig 처럼 객체를 생성하고 관리하면서 의존관계 연결해주는것을 
IoC컨테이너또는 DI컨테이너라 한다
의존관계 주입에 초점을 맞추어 최근에는 주로 DI컨테이너라 한다
또는 어셈블러, 오브젝트 팩토리 등으로 불리기도 한다.


"스프링 컨테이너"
ApplicationContext 를 스프링 컨테이너라고 한다.
기존에는 AppConfig 를 사용해서 직접 객체를 생성하고 DI를 했지만 이제부터는 스프링 컨테이너를 통해서
사용한다.

스프링컨테이너는 @Configuration 이 붙은 AppConfig를 설정 및 구성 을 정보로 사용한다
여기서 @Bean이라 적힌 메서드를 모두 호출해서 반환된 객체를 스프링 컨테이너에 등록한다
이렇게 스프링 컨테이너에 등록된 객체를 스프링 빈이라 한다.

스프링 빈은 @Bean 이 붙은 메서드의 명을 스프링 빈의 이름으로 사용한다 (memberService, orderService)

이전에는 필요한 객체를 AppConfig를 사용해서 직접 조회했지만 이제부터는 스프링 컨테이너를 통해서 필요한 스프링 빈 을 찾고, 스프링은 빈은 applicationContext.getBean() 메서드를 통해서 찾을수 있다.

기존에는 직접 자바코드로모든것을 했다면 바뀐 내용은 스프링 컨테이너에 객체를 스프링 빈으로 등록하고,
스프링 컨테이너에서 스프링 빈을 찾아서 사용하도록, 변경되었다

/5/12
추가한Annotation종류
테스트 메소드 정하기 @Test
테스트의 이름 정하기 @DisplayName
해당 클래스를 Spring 컨테이너로 지정할때 쓰는 @Configuration


ApplicationContext ac  = new AnnotationConfigurationContext(AppConfing.Class);
AnnotationConfigApplicationContext  ac = new AnnotationConfigApplication(AppConfig.Class); 의 차이.

"ApplicationContext ac  = new AnnotationConfigurationContext(AppConfing.Class);"
+내가 설정한 스프링 컨테이너 AppConfig의 @Bean이나 정보들을 ac 란 ApplicationContext란 객체에 넣고 사용하길 의미.
(이 코드는 AnnotationConfigApplicationContext를 사용하여 AppConfig 클래스의 빈 정보를 읽어들여 Spring 컨테이너를 초기화하고,
 이를 ac라는 ApplicationContext 객체에 담고. 이후에는 ac를 통해 해당 스프링 컨테이너에 등록된 빈들을 사용)

AnnotationConfigApplicationContext  ac = new AnnotationConfigApplication(AppConfig.Class);
+-> AppConfig라는 스프링 컨테이너의 @Bean정보를 ac에 담겠다.




@Test
@DisplayName(Application Bean Info)
    void findApplicationBean(){
        String[] beanDefinitionNames = ac.getBeanDefinitionNames();
        for (String beanDefinitionName : beanDefinitionNames) {
            BeanDefinition beanDefinition = ac.getBeanDefinition(beanDefinitionName);
            if(beanDefinition.getRole() == BeanDefinition.ROLE_APPLICATION){
                Object bean = ac.getBean(beanDefinitionName);
                System.out.println("name = " + beanDefinitionName+" object = " + bean);
            }

        }
    }

 ↗
"@DisplayName(Application Bean Info)"
+
bean 저장소에는 배열처럼 0번쨰 방(key) 의 내가 지정한 BeanName(value) 상수값이 자동으로 지정된다.
그래서 getRole()이라는 int 반환 타입으로 key 값을 순회하며 ROLE_APPLICATION (내가 생성한) 의 빈 생성 상수 값(KEY)과 비교하여
순회한 int (key) 값과 내가만든 빈은 상수로 생성된 (KEY)값이 같은지를 비교 하고 같으면 오브젝트 타입으로 Bean의 정보를 저장시키고
zero에서 last index 까지 순회하며 출력한다.


애플리케이션 컨텍스트 와 빈팩토리
(ApplicationContext, BeanFactory)
**BeanFactory**와 **ApplicationContext**는 Spring 프레임워크의 핵심 구성 요소로, 빈(Bean)의 생명주기를 관리하고 의존성 주입을 처리하는 역할을 함

- **BeanFactory**: 이것은 Spring 컨테이너의 최상위 인터페이스로, 가장 기본적인 컨테이너임. BeanFactory는 빈의 정의와 의존성 주입을 처리하며, 빈의 생성, 관리, 조회 등의 역할을 담당함. BeanFactory는 빈을 관리하고 검색하는 기능을 제공하며, 이를 통해 객체의 생성, 초기화, 소멸 등의 생명주기를 관리하고, 객체 간의 의존성을 주입하여 느슨한 결합과 유연한 코드 관리를 가능하게 함.

- **ApplicationContext**: 이것은 BeanFactory 인터페이스의 하위 인터페이스로, BeanFactory에 부가기능을 추가한 것입니다¹⁴¹⁵. ApplicationContext는 BeanFactory의 모든 기능을 포함하며, 메시지 리소스 처리, 이벤트 발행, 웹 애플리케이션 모듈 등 더 많은 기능을 지원함. ApplicationContext는 BeanFactory의 기능 외에도 자원 처리 추상화, 메시지 및 국제화, 이벤트 지원 등을 제공하고 있어, BeanFactory보다 더 자주 사용됨

실제 업무에서는 다음과 같은 방식으로 BeanFactory와 ApplicationContext가 사용됨
- **BeanFactory 사용 사례**: BeanFactory는 가장 기본적인 컨테이너로서, 빈의 정의와 의존성 주입을 처리하는 역할함¹¹. 이는 Spring에서 IoC 컨테이너의 가장 기본적인 형태이며, 스프링 빈을 관리하고 조회하는 역할을 함. BeanFactory는 빈 객체들의 라이프사이클을 관리하며 싱글톤 객체들을 캐싱하여 동일한 객체들을 재사용함

- **ApplicationContext 사용 사례**: ApplicationContext는 BeanFactory의 모든 기능을 포함하며, 메시지 리소스 처리, 이벤트 발행, 웹 애플리케이션 모듈 등 더 많은 기능을 지원함 예를 들어, 웹 애플리케이션에서는 웹 어플리케이션에 위치한 곳에서 xml파일을 읽어 설정 정보를 로딩하는 XmlWebApplicationContext를 사용할 수 있음. 또한, @Configuration 어노테이션이 붙은 클래스를 이용하여 설정 정보로 로딩하는 AnnotationConfigApplicationContext를 사용할 수도 있음². 이러한 ApplicationContext를 사용하면, 개발자는 @Configuration이 붙은 구체적인 팩토리 클래스를 알 필요가 없으며, 일관된 방식으로 원하는 빈을 가져올 수 있음

ApplicationContext는 다양한 interface를 extends함 그중 핵심이 되는 interface는
MessageSource -> 국제화 기능
EnvironmentCapable-> 환경변수 로컬, 개발 , 운영,스테이징환경 등을 구분해서 처리
ApplicationEventPublisher-> 이벤트를 발행하고 구독하는 모델을 편리하게 지원
ResourceLoader-> 파일 클래스패스 외부등에서 리소스를 편리하게 조회

ApplicationContext  -> BeanFactory 기능을 상속 받는다
ApplicationContext 는 빈 관리기능 + 편리한 주요(윗줄 4가지 기능을)을 포함한다
BeanFactory를 직접 사용할 일은 다소 적다 다중상속을 받은 ApplicationContext 를 자주 사용한다
BeanFactory나,ApplicationContext를 스프링 컨테이너라고 정의할수 있다.



싱글톤 컨테이너

웹 애플리케이션과 싱글톤

스프링은 태생이 기업용 온라인 서비스 기술을 지원하기 위해 탄생한 서비스이다
대부분 스프링 애플리케이션은 웹 애플리케이션이다 ( 웹이 아닌 애플리케이션도 개발할수 있다 둘다 가능
이긴 하나 관용적으로 웹을 개발하는데 더 많이 활용, 이용된다)
웹 애플리케이션은 보통 여러 클라이언트가 동시에 요청을 한다

지금까지 개발한 내용으로 Singleton 패턴이 없는 순수한 pureContainer 에선
TPS나 , JVM 가비지 컬렉션 , 메모리 문제등 다양한 이슈가 발생할수 있기 때문에

클래스의 인스턴스가 1개만 생성되는것을 보장하는 디자인패턴인
Singleton 패턴을 임의한다.

싱글톤의 장점은 클라이언트 요청이 올때마다 객체를 생성하는것이 아니라 만들어진 객체를
재활용 하기때문에 메모리나 성능 면에서 우수하다고 할수 있지만 문제점도 있다
싱글톤의 패턴의 문제점은 다음과 같다
"싱글톤 패턴을 구현하는 코드 자체가 많아지고 길어진다"
"의존관계상 클라이언트가 구체 클래스에 의존한다 dip 위반"
"클라이언트가 구체클래스에 의존해서 ocp 원칙을 위반할 가능성이 높음"
"테스트하기가 어려움 (생성할때 instance에 값을 지정하거나 박아놓고 시작 하기 때문에
다양한 상황에 유연한 테스트가 어려울수 있음)
"내부 속성을 변경하거나 초기화 하기 어렵다"
"private 생성자로 자식 클래스를 만들기가 어려움"
"결론적으로 유연성이 떨어짐"
"안티패턴으로 불리기도 함"

위와 같은 싱글톤 디자인패턴의 문제로 인하여
Spring에서 제공하는 싱글톤 컨테이너를 활용함
1스프링 컨테이너는 싱글톤 패턴을 적용하지 않아도
객체 인스턴스를 싱글톤으로 관리한다
2 스프링 컨테이너는 싱글톤 컨테이너 역할을 한다 싱글톤 객체를 생성하고 관리하는 기능을 싱글톤 레지스트리라한다
3스프링컨테이너는 이런 기능 덥군에 싱글턴 패턴의 모든 단점을 해결하면서 객체를 싱글톤으로 유지할수있다
+"싱글톤 패턴을 위한 지저분한 코드가 들어가지 않아도 된다 DIP,ODCP,테스트,pritvate 의 제약으로 부터 자유롭게 싱글톤을 사용할수 있다."

@Configuration 과 Singleton

이떄까지 개발한 내용으론 @Configration 이라는 어노태이션을 이용한
Spring 컨테이너로 설정한 AppConfig의 자바코드를 살펴 보면
Dependency Injection 을 interface로 역할과 구현을 분리시켜놓았다

코드를 살펴보면 new 로 해서 각각의 methode가 실행될때마다 새로운 객체를 생성해서 불러오는데
이러면 Spring컨테이너는 Single톤을 유지할수 있을까?

라는 의문점에서 테스트 코드를 작성해보았다.


이유는 다음과 같다
@Configuration이라는 어노테이션으로 AppConfig.class 를 SpringContainer로 지정할때
우리가 만든 AppConfig를 자체로 사용하는게 아니라 , AppConfig@GCLIB 라는
바이트코드조작 라이브러리을 이용하여 내가만든 AppConfig를 읽고 , AppConfig를 상속받는
 AppConfig@GCLIB라는 instance class를 생성한다.그리고 스프링 컨테이너로 등록한다

내가만든 Class에 내가만든 method를 오버라이드 하는데, 그 안에 아마도 이런 예상코드가 작성 되어있는거 같다
@Bean
public MemberRepository memberRepository(){

	if(MemoryMemberReposiotry 가 이미 있으면){
	return 스프링 컨테이너에서 찾아서 반환
	}else{ // 없으면
	기존로직을 호출해서 MemoryMemberRepository 를 생성하고 새롭게 스프링 bean에 등록
	후 return 반환.
}
@Bean 이 붙은 메서드 마다 이미 스프링빈이 존재하면 존재하는 빈을 반환하고
스프링빈이 없으면 생성해서 스프링 빈으로 등록해서 반환하는 코드가 동작한다.
작성한 SingletonSpringContainerTest 코드 를 보면 알수 있듯이
예상했던 것과 다르고 SpringContainer는 Singleton 을 보장하였다



이유는 다음과 같다
@Configuration이라는 어노테이션으로 AppConfig.class 를 SpringContainer로 지정할때
우리가 만든 AppConfig를 자체로 사용하는게 아니라 , AppConfig@GCLIB 라는
바이트코드조작 라이브러리을 이용하여 내가만든 AppConfig를 읽고 , AppConfig를 상속받는
 AppConfig@GCLIB라는 instance class를 생성한다.그리고 스프링 컨테이너로 등록한다

내가만든 Class에 내가만든 method를 오버라이드 하는데, 그 안에 아마도 이런 예상코드가 작성 되어있는거 같다
@Bean
public MemberRepository memberRepository(){

	if(MemoryMemberReposiotry 가 이미 있으면){
	return 스프링 컨테이너에서 찾아서 반환
	}else{ // 없으면
	기존로직을 호출해서 MemoryMemberRepository 를 생성하고 새롭게 스프링 bean에 등록
	후 return 반환.
}
@Bean 이 붙은 메서드 마다 이미 스프링빈이 존재하면 존재하는 빈을 반환하고
스프링빈이 없으면 생성해서 스프링 빈으로 등록해서 반환하는 코드가 동작한다.





